<!--The content below is only a placeholder and can be replaced.-->
<div style="text-align:center">
  <h1>
    {{ title }}!
  </h1>
  <h2>
    {{ name }}!
  </h2>
  <p>{{randomVariable}}</p>
  <img width="300" alt="Angular Logo" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTAgMjUwIj4KICAgIDxwYXRoIGZpbGw9IiNERDAwMzEiIGQ9Ik0xMjUgMzBMMzEuOSA2My4ybDE0LjIgMTIzLjFMMTI1IDIzMGw3OC45LTQzLjcgMTQuMi0xMjMuMXoiIC8+CiAgICA8cGF0aCBmaWxsPSIjQzMwMDJGIiBkPSJNMTI1IDMwdjIyLjItLjFWMjMwbDc4LjktNDMuNyAxNC4yLTEyMy4xTDEyNSAzMHoiIC8+CiAgICA8cGF0aCAgZmlsbD0iI0ZGRkZGRiIgZD0iTTEyNSA1Mi4xTDY2LjggMTgyLjZoMjEuN2wxMS43LTI5LjJoNDkuNGwxMS43IDI5LjJIMTgzTDEyNSA1Mi4xem0xNyA4My4zaC0zNGwxNy00MC45IDE3IDQwLjl6IiAvPgogIDwvc3ZnPg==">
</div>
<h2>Custom Example of coding:</h2>


<h3>Lesson 06 -> Change a TEXT dinamically using an input and the DIRECTIVE [(ngModel)]="var":</h3>
<ul>
  <li>You have to import into the app.module.ts the class:</li>
  <li><code>import &#123; FormsModule } from '@angular/forms';</code></li>
  <li>And add into the "imports" Array the "FormsModule"</li>
  <li>"FormsModule" it is a TypeScript object</li>
</ul>
<input type="text" [(ngModel)]="randomVariable">
<p>{{randomVariable}}</p>
<hr>
<h3>Lesson 10 -> A Basic Project Setup using Bootstrap for Styling</h3>
<ul>
  <li>Install/import bootstrap</li>
  <li>Type ->  npm install --save bootstrap@4</li>
  <li>Add into -> Config File -> angular.json -></li>
  <li><code>"build": &#123;<br>
    "styles": [<br>
    "node_modules/bootstrap/dist/css/bootstrap.min.css",<br>
    "src/styles.css",<br>
    ],&#125;</code></li>
  <li><div class="alert alert-primary" role="alert">
    Bootstrap Style works!
  </div></li>
</ul>
<hr>
<h3>Lesson 13 -> How an Angular App gets Loaded and Started</h3>
<ul>
  <li>I'm in the AppComponent HTML!</li>
  <li>The index.html file is the single html file called by Angular. That's why Angular is an a "Single Page Application"</li>
  <li>The index.html integrate the app.component.html by the <code>&#60;app-root>&#60;/app-root></code></li>
  <li>The Name "app-root" is declared into the app.component.ts file at the Selector parameter:<br> <code>@Component(&#123;<br>
    selector: 'app-root',&#125;</code></li>

  <li>The first code executed by Angular is the code conteined by the "main.ts" file, where in fact is present the <code>platformBrowserDynamic().bootstrapModule(AppModule)
    .catch(err => console.error(err));</code> declaration that called the AppModule Class into the bootstrapModule.</li>
  <li>Into the AppModule class it is declared and imported the AppComponent Class passing it into the Decorator @NgModule() into the JS object "bootstrap" parameter: <br> <code>@NgModule(&#123;<br>bootstrap: [AppComponent]&#125;)</code></li>
</ul>
<li> Now Angular is able to build the structure described between main.ts and app.component.ts</li>
<h3>Lesson 15 -> Creating a New Component</h3>
<h4>Manually Creation:</h4>
<ul>
  <li>Creation a new directory with the same name of the component, like "app/server" folder</li>
  <li>into the "app/server" folder, create the Typescript server.component.ts file</li>
  <li>In order to use outside the Class "ServerComponent", add the code <code>export class ServerComponent &#123; &#125;</code></li>
  <li>To define the Class "ServerComponent" it is not just a normal Typescript class but a Component, we have to add the Decorator <b>@Component()</b></li>
  <li>The Decorator @Component has to be imported <code>import &#123;Component} from '@angular/core'; </code></li>
  <li>Next step is pass the JavaScript object to the @Component Decorator:<br><code>
    @Component(&#123; <br>
    selector: 'app-server',<br>
    templateUrl: './server.component.html'
    &#125;)
  </code>
  </li>
  <li>The <b>selector</b> JS object is the name used to called the Class.component.html file content, into another Class.component.html file using the tags <code>&#60;app-server>&#60;/app-server></code> </li>
  <li>The <b>templateUrl</b> JS object point to the path where is located the HTML compenent that angular will used to render the sub page content into the e.g. <code>&#60;app-server>&#60;/app-server></code> </li>
</ul>
<hr>
<h3>Lesson 16 -> Understanding the Role of AppModule and Component Declaration</h3>
<ul>
  <li>To use the new Component, we have to import into the Decorator @NgModule() contained into the app.module.ts into the "declarations:" properties.</li>
  <li><code>NgModule(&#123;<br>
    declarations: [<br>
    AppComponent,<br>
    <b>ServerComponent</b>
    ]&#125;</code></li>
  <li> Angular don't know if a new component exist or not, we have to add it by default into the @NgModule() decorator, and import the class<br>
    <code>import &#123; <b>ServerComponent</b> &#125; from './server/server.component';</code></li>
</ul>
<hr>
<h3>Lesson 17 -> Using Custom Components</h3>
<ul>
  <li>To include the new component into another component, after to import the new component into the app.module.ts, we have to user the <code>&#60;app-server>&#60;/app-server></code> like this:</li>
  <app-server></app-server>
</ul>
<hr>
<h3>Lesson 18 -> Creating Components with the CLI & Nesting Components</h3>
<ul>
  <li>To create a component using the terminal:  </li>
  <li>ng generate componet NAME</li>
  <li>ng g c NAME</li>
  <li>this command will create 4 files and a folder<br>
    name.component.css -> for style<br>
    name.component.html<br>
    name.component.spec.ts -> for test<br>
    name.component.ts<br>
  </li>
  <li><app-servers></app-servers></li>
  <hr>
  <h3>Lesson 19 -> Working with Component Templates</h3>
  <li>Instead of declare and pass a templateUrl as a file, it is possible also to pass other template or add some HTML code into the @Component() decorator, passing the <b>template</b> object instead of the templateUrl, e.g.:</li>
  <li><code>@Component(&#123;<br>
    selector: 'app-servers-l19',<br>
    <b>template</b>: '&#60;app-server>&#60;/app-server>',<br>
    styleUrls: ['./servers-l19.component.css']<br>
    &#125;)</code></li>
  <li>If we call the &#60;app-server-l19>&#60;/app-server-l19> into the app.component.html, they code will call the &#60;app-server>&#60;/app-server> passing through the template </li>
  <li><app-servers-l19></app-servers-l19></li>
</ul>
<hr>
<h3>Lesson 20 -> Working with Component Styles</h3>
<ul><li>The decorator @Component() between its object define the style</li>
  <li>If you want to define a style content in a external file e.g.:<br>
    <code><b>styleUrls:</b> ['./servers-l19.component.css']</code></li>
  <li>If you want to add the style in line e.g.:<br>
    <code>styles: [`h3 &#123;<br>
      color: blue;<br>
      `&#125;]</code></li>
</ul>
<hr>
<h3>Lesson 21 -> Fully Understanding the Component Selector</h3>
<ul><li>
  There are different way to declare the <b>selector</b> into the @Component decorator.
</li>
  <li>Using css selector:<br>
    <code>selector: 'app-servers'</code></li>
  <li>Selecting by <b>elements</b> using [''] as attribute:<br>
    <code>selector: '[app-servers]'</code><br>
    And in the component.html we are going to call it as attribute:<br>
    <code>&#60;div app-servers> &#60;/div></code></li>
  <li>It is possible also to select the component by <b>class</b>:<br>
    <code>selector: '<b>.app-servers</b>'</code><br>
    And in the component.html we are going to call it as attribute:<br>
    <code>&#60;div class="<b>app-servers</b>"> &#60;/div></code></li>
</ul>

<hr>
<h3>Lesson 23 -> What is Databinding?</h3>
<ul>
  <li>Databinding = Communication</li>
  <li>TypeScript Code ---->  Template</li>
  <li>1 -> <b>String Interpolation</b> &#123; &#123; data }}</li>
  <li>2 -> <b>Property Binding</b> [property]="data"</li>
  <li>3 -> <b>Event Binding</b> (event)="expression"</li>
  <li>4 -> Combination of Both: <b>Two-way-Binding</b> [(ngModel)]="data"</li>
</ul>
<hr>
<h3>Lesson 24 -> String Interpolation</h3>
<ul>
  <li>With String Interpolation it is possible pass the information content into the component.ts like variable or method return (e.g. server-l24.component.ts)<br>
    <code><b>serverId</b>: number = 10;<br>
      <b>serverStatus</b>: string = 'offline';<br><br>
      getServerStatus()&#123;<br>
      return this.serverStatus;<br>
      }</code></li>

  <li>Then it is possible to pass those string interpolation into the component.html (e.g. server-l24.component.html)<br>
    <code>The server with ID &#123; &#123; serverId &#125;&#125; is &#123; &#123; getServerStatus() }}</code></li>
  <li><app-server-l24></app-server-l24></li>
</ul>
<hr>
<h3>Lesson 25 -> Property Binding</h3>
<ul>
  <li>If we want the binding a property of a button, for example if we want to disable or enable it dynamically, it is possible to use property binding.</li>
  <li>e.g. into the serves-l25.component.ts file we will create:<br>
    <code>allowNewServer = false;</code><br>
    <code>constructor() &#123;<br>
      setTimeout(() => &#123; this.allowNewServer = true;}, 2000);<br>
      &#125;
    </code></li>
  <li>into the html code will binding the property "disabled" into square brackets [disabled]<br>
    <code> &#60;button class="btn btn-primary" [disabled]="!allowNewServer">Add Server&#60;/button></code>
  </li>
  <li>Result:<br>
    <app-servers-l25></app-servers-l25></li>
  <li>The setTimeout function is executed once into the constructor, then the button become enable after 2sec</li>
</ul>
<hr>
<h3>Lesson 26 -> Property Binding vs String Interpolation</h3>
<p>Using Property Binding instead with String Interpolation</p>
<ul>
  <li>Instead of using a code like <code>&#123; &#123; data }}</code> it is useful to use the property binding like:<br>
    <code>&#60;p [innerText]="data">&#60;/p></code><br>
    This is allowed to change the property inner text and show the text content into the variable.
  </li>
</ul>
<hr>
<h3>Lesson 27 -> Event Binding</h3>
<p>Using Property Binding instead with String Interpolation</p>
<ul>
  <li>
    To create a event button that is triggered by the user<br>
    add for example the <code>(click)="eventTriggered()"</code> that call the function eventTriggered()</li>
  <li>The function in this case will change the variable &#123; &#123; testEventBinding }}</li>
</ul>
<app-l27-event-binding></app-l27-event-binding>

<hr>
<h3>Lesson 29 -> Passing and Using Data with Event Binding</h3>
<p>When an event happens, it is possible to pass the "$event" variable to the method</p>
<p>$event represent the data of the event</p>
<ul>
  <li>As for the click event, also for the input field it is possible to set the (input) event, passing the $event into the method called</li>
  <li><code>      &#60;input type="text"<br>
    class="form-control"<br>
    id="inlineFormInputName"<br>
    placeholder="Type something"<br>
    <b>(input)="onUpdateName($event)"</b>></code></li>
  <li>In the Component side:<br>
    <code> onUpdateName(event: Event)&#123;<br>
      this.eventText = (&#60;HTMLInputElement>event.target).value;<br>
      }<br>
    </code>
  </li>
  <li>It is mandatory to explicity declare the event with the formula (&#60;HTMLInputElement>event.target).value;</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement" target="_blank">HTMLInputElement</a>
  </li>
</ul>
<app-l29-data-event></app-l29-data-event>
<hr>
<h3>Lesson 31 -> Two-Way-Databinding</h3>
<p>Important> To be able to use 'ngModel', the FormsModule (from @angular/forms) needs to be added to your imports[] array in the AppModule (should be there by default in a CLI project)!</p>
<p></p>
<ul>
  <li>Two way data binding can is use to chain input and output together, in fact the input is filled by the variable delcared into the [(ngModel)] data</li>
  <li>when the input data changed also the variable changes</li>
  <li><code>      &#60;input type="text"<br>
    class="form-control"<br>
    id="inlineFormInputName"<br>
    placeholder="Type something"<br>
    <b>[(ngModel)]="eventText"</b>></code></li>
  <li>As you can see, the placeholder is override by the ngModel content</li>
</ul>
<app-l30-two-way-databinding></app-l30-two-way-databinding>


<hr>
<h3>Lesson 33 -> Assignment</h3>
<p>Important> To be able to use 'ngModel', the FormsModule (from @angular/forms) needs to be added to your imports[] array in the AppModule (should be there by default in a CLI project)!</p>
<p></p>
<ul>
  <li>Add a Input field which updates a property ('username') via Two-Way-Binding</li>
  <li>Output the username property via String Interpolation (in a paragraph below the input)</li>
  <li>Add a button which may only be clicked if the username is NOT an empty string</li>
  <li>Upon clicking the button, the username should be reset to an empty string</li>
</ul>
<app-l33-assignment></app-l33-assignment>

<hr>
<h3>Lesson 35 -> Using ngIf to Output Data Conditionally</h3>
<p>The ngIf directive allow to add or remove from the HTML structure the elements content in it, ngIf changes the structure of our DOM</p>

<ul>
  <li>The syntax is *ngIf="number > 100"</li>
  <li>If you put the ngIf into an element, that element will be the border of the directive, in this case <br><code>&#60;div *ngIf="number > 100"> Content div &#60;/div></code></li>
  <li>Choose a number between 0 and 100. If the number is > 100 there will be spot an error</li>
</ul>
<app-l35-directive-ngif-output></app-l35-directive-ngif-output>
<hr>
<h3>Lesson 36 -> Enhancing ngIf with an Else Condition</h3>
<p>If you need to add another condition as if else directive, it is possible usinge the *ngIf="condition; else otherCondition"</p>
<ul>
  <li>The else syntax is *ngIf="number > 100; else numberIsOk"</li>
  <li>The <b>numberIsOk</b> it is a <b>local reference</b> that it is possible to associate like <code>&#60;ng-template <b>#numberIsOk</b>></code></li>
  <li>The local reference with the character <b>#</b> becomes a <b>marker</b> that enable the ng-template content.</li>
  <li>Choose a number between 0 and 100. If the number is > 100 there will be spot an error, else if number <= 100 there will be spot a success message.</li>
</ul>
<app-l36-directive-ngif-else></app-l36-directive-ngif-else>

<hr>
<h3>Lesson 37 -> Styling Elements Dynamically with ngStyle</h3>
<p>With ngStyle we are able to dynamically update the style of the element</p>
<ul>
  <li>For this example I create three random color that together can give a background color to the div.</li>
  <li>The ngStyle will execute the getColor() function that will return the color value <code>[ngStyle]="&#123;backgroundColor: getColor()}"</code></li>
  <li>The ngStyle will add the new style without overlapping</li>
</ul>
<app-l37-ngstyle></app-l37-ngstyle>

<hr>
<h3>Lesson 38 -> Applying CSS Classes Dynamically with ngClass</h3>
<p>With ngClass we are able to dynamically update the class of the element</p>
<ul>
  <li>Syntax <code>[ngClass]="&#123;highContrastClass: highContrast === true}"</code></li>
  <li>"highContrastClass" is the class content in the component.css file</li>
  <li>"highContrast === true" is the condition that will apply the "highContrastClass" class to the elements </li>
  <li>Important to notice, the class doesn't overlap the pre-existent style value</li>
</ul>
<app-l38-ngclass></app-l38-ngclass>
<hr>
<h3>Lesson 39 -> Outputting Lists with ngFor</h3>
<p>ngFor is the equivalent of a normal "for" directive that in this case is use as a foreach</p>
<ul>
  <li>Syntax <code>*ngFor="let data of fromArrayData"</code></li>
  <li>"data" is the single and present value of the array</li>
  <li>"fromArrayData" is the array from the component.ts </li>
</ul>
<app-l39-ngfor></app-l39-ngfor>
<hr>
<h3>Lesson 40 -> Assignment</h3>
<div class="container">
  <div class="row">
    <div class="col-xs-12">
      <ol>
        <li>Add A button which says 'Display Details'</li>
        <li>Add a paragraph with any content of your choice (e.g. 'Secret Password = tuna')</li>
        <li>Toggle the displaying of that paragraph with the button created in the first step</li>
        <li>Log all button clicks in an array and output that array below the secret paragraph (maybe log a timestamp or simply an incrementing number)</li>
        <li>Starting at the 5th log item, give all future log items a blue background (via ngStyle) and white color (ngClass)</li>
      </ol>
    </div>
  </div>
</div>
<app-l40-assignment></app-l40-assignment>

<hr>
<h3>Section 3 -> Course Project - The Basics</h3>
<hr>
<app-header></app-header>
<div class="container">
  <div class="row">
    <div class="col-xl-12">
      <app-recipes></app-recipes>
      <app-shopping-list></app-shopping-list>
    </div>
  </div>
</div>


<hr>
<h3>Section 5 -> Components & Databinding Deep Dive</h3>
<hr>
<div class="container">
  <app-cockpit
    (serverCreated)="onAddServerAdded($event)"
    (blueprintCreated)="onBlueprintAdded($event)"
  ></app-cockpit>
  <hr>
  <div class="row">
    <div class="col-xs-12">
      <app-server-element
        *ngFor="let serverElement of serverElements"
        [srvElement]="serverElement">
      </app-server-element>
    </div>
  </div>
</div>




<hr>
<h3>Lesson 65 -> Binding to Custom Properties -> @Input() </h3>
<p>Trying to access to the an element that are coming from another component</p>
<p>To have access to the component properties from outside of the component, the component needs the Decorator @Input()</p>
<p>So the Input() decorator allow from outside to pass data inside. @Input() makes a property bindlable from outside.</p>
<ul>
  <li>For example into section5/server-element.component.ts:<br>
    <code>&#60;strong *ngIf="element.type === 'server'" style="color: red">&#123; &#123; element.content }}&#60;/strong><br>
      &#60;em *ngIf="element.type === 'blueprint'">&#123; &#123; element.content }}&#60;/em></code></li>
  <li>create into the component.ts the property that represent the object that we need in our component using the @Input decorator, in this case "element":<br>
    <code>@Input() element: &#123; type: string, name: string, content: string};</code><br>
    that are all now out <i>type definition</i></li>
  <li>Outside of this component, it will be the object data with the data that we have to pass into the previous component
    <br><code> serverElements = [&#123;type: 'server', name:'TestServer', content: 'Just a Test!'}];</code></li>
  <li>To access to the new component from outside: <br>
    <code>&#60;app-server-element [element]="serverElements">&#60;/app-server-element></code></li>
</ul>
  <hr>
  <h3>Lesson 66 -> Assigning an Alias to Custom Properties -> @Input('alias')</h3>
  <p>It is possible to assign an Alias to the @Input() Decorator like <code>@Input('Alias')</code></p>
  <ul>
    <li>
      <code>@Input('srvElement') element: &#123; type: string, name: string, content: string};</code>
    </li>
    <li>
      <code>&#60;app-server-element [srvElement]="serverElements">&#60;/app-server-element></code>
    </li>
  </ul>
  <hr>
  <h3>Lesson 65 -> Binding to Custom Events -> @Output() -> EventEmitter</h3>
  <ul>
    <li>
      To send outside data or event outside to the components, we have to use the EventEmitter object. <br>
      With EventEmitter object, now we get two event emitters and that's the first step, eventEmit
      <code>serverCreated = new EventEmitter<&#123;serverName: string, serverContent: string}>(); <br>
        blueprintCreated = new EventEmitter<&#123;serverName: string, serverContent: string}>();</code>
    </li>
    <li>Then we need we need two method that will called the serverCreated and the blueprintCreated with the emit() method. This will emit a new event of this type so of the server created using this evetEmitter<br>
      <code>onAddServer()&#123;<br>
        this.serverCreated.emit(&#123;<br>
        serverName: this.newServerName,<br>
        serverContent: this.newServerContent<br>
        });<br>
        }<br>
        <br>
        onAddBlueprint()&#123;<br>
        this.blueprintCreated.emit(&#123;<br>
        serverName: this.newServerName,<br>
        serverContent: this.newServerContent<br>
        });<br>
        }</code></li>
    <li>To make blueprintCreated and serverCreated listenable from outside we have to use the @Output decorator</li>
  </ul>


<hr>
<H3>Lesson 71 -> Overriding View encapsulation</H3>
<p>Whit the Properties @Component "encapsulation", we can declare if we want to override the component CSS or not.</p>
<p>There three way to do that:</p>

<ul>
  <li>
    @Component(&#123; <br>
    encapsulation: ViewEncapsulation.(method)<br>
    })
  </li></ul>
<p>Methods:</p>
  <ol>
    <li><code>encapsulation: ViewEncapsulation.<b>Emulated</b></code><br>The default way to use the CSS encapsulated into the methods.</li>
    <li><code>encapsulation: ViewEncapsulation.<b>None</b></code><br>The none methods will be disable the CSS of the component.</li>
    <li><code>encapsulation: ViewEncapsulation.<b>Native</b></code><br>Native uses the shadow DOM technology. This should give you the same result as before with emulated but only in browsers which support it which is why for most cases, you want to choose emulated but be aware that you could switch to none or native </li>
  </ol>

<h3>Lesson 72 -> Using Local References in Templates</h3>

<p>A local reference is another option to use instead to use the two-way binding.</p>
<p>A local rederence can be placed on any HTML element, so not only on an input element, on anything you see here in the template and you add with a ashtag # and then a name of your choice, like for example server name since this is what reference will hold, a reference to this element like:</p>
<p><code>&#60;input type="text"    <br>
                class="form-control"<br>
                <b>#serverNameInput</b>></code></p>
<p>Now important, this reference will hold a reference to this element, so not to the value we entered there, to the whole HTML element with all its properties.</p>
<p>You can create and yse them evertwgere in your template but importat, only there, not inside your TypeScript code, only in the template.</p>
<input type="text"
class="form-control"
#serverNameInput
placeholder="Qualcosa">
This is the Placeholder of the Input above -> {{serverNameInput.placeholder}} <br>
This is the Type of the Input above -> {{serverNameInput.type}}
<br>
<hr>
<h3>Lesson 74 -> Getting Access to the Template & DOM with @ViewChild</h3>
<p>To get access to the local reference from the component.ts we have to use the <a href="https://angular.io/api/core/ViewChild">@ViewChild()</a> Decorator</p>
<p>If for example with want to use the input with the local reference '#reference74': </p>
<p><code>&#60;input type="text"    <br>
  class="form-control"<br>
  <b>#reference74</b>></code></p>
<p>and in the component.ts we will add the @ViewChild decorator declaring the reference as a "ElementRef" object like:</p>
<p><code><b>@ViewChild('reference74', &#123;static: true}) reference7: ElementRef;</b></code></p>
<p>Whith Angular 8, the @ViewChild() should be @ViewChild('...',  &#123;static: true}) SINCE  we'll also use thte selected element in ngOnInit</p>
<input type="text"
       class="form-control"
       #reference74
       placeholder="Qualcosa">
<button class="btn btn-primary" (click)="clickOnButton(reference74)">Send the reference</button><br>
<B>{{reference74Out}}</B>
<p>We can finally access to the reference from the TypeScript passing the value as a properties into method:</p>
<p><code>clickOnButton(reference74)</code></p>
<p>To get access to the properties of the element, we have to use the "natvieElement" method:</p>
<p><code>console.log(this.reference74.nativeElement.value);</code></p>
<p>So without two way binding, we already send the data using a reference throught a method accessing to the Typescript, and then loop back with a variable using a String Interpolation</p>

<hr>
<h3>Lesson 75 -> Projecting Content into Components with ng-content</h3>
<p>There is another way to pass information from outside into the Template.</p>
<p>Sometimes you have complex HTML code like:</p>
<p>    <code>&#60;strong *ngIf="element.type === 'server'" style="color: red">&#123; &#123; element.content }}&#60;/strong><br>
  &#60;em *ngIf="element.type === 'blueprint'">&#123; &#123; element.content }}&#60;/em></code></p>
<p>And if you want to pass those information into a component from outside it is possible to use the :ng-content". </p>
<ul>
  <li>If for example we take the code above and we want to pass that code into the template component <code> &#60;app-l75-ngcomponent>&#60;/app-l75-ngcomponent></code><br>
  It is possible to write something like: <br>
  <code>&#60;app-l75-ngcomponent> <br>
    &#60;p *ngIf="status75 == false"> status is NOT ok &#60;/p> <br>
    &#60;p *ngIf="status75 == true"> status is OK &#60;/p> <br>
    &#60;/app-l75-ngcomponent></code></li>
</ul>
status 75 is -> {{status75}}
<button class="btn btn-primary" (click)="changeStatus75()">Change Status</button>
<app-l75-ngcomponent>
  <p *ngIf="status75 == false"> status is NOT ok </p>
  <p *ngIf="status75 == true"> status is OK </p>
</app-l75-ngcomponent>

<hr>
<h3>Lesson 76 -> Understanding the Component Lifecycle</h3>

<p>If a new component is created in Angular and of course Angular is responsible for creating these components when it finds one of our selectors for example, it will instantiate a new version of that component and add it into the DOM. So once a new component is instantiated, Angular goes through a couple of different phases in this creation process and it will actually give us a chance to hook into these phases and execute some code.</p>
<p>We can hook into these phases by implementing some methods Angular will call if they are present.</p>

<ul>
  <li>ngOnChanges -> The first phase, the first hook we can hook into is ngOnChanges and this may actually be executed multiple times, it's executed right at the start when a new component is created but thereafter, it's also always called whenever one of our bound input properties changes and with that, I mean properties decorated with @input, so whenever these properties received new values.</li>
  <li>ngOnInit -> Now the second hook is ngOnInit, this method gets executed once the component has been initialized. This does not mean that we can see it, it has not been added to the DOM yet so to say, it has not been displayed yet but Angular finished the basic initialization, our properties can now be accessed and initialized for example, so the object was created you could say and if you're interested, ngOnInit will run after the constructor. </li>
  <li>ngDoCheck -> Then we have ngDoCheck, that will also run multiple times,    actually this method will be executed a lot because this will run whenever change detection runs. Now change detection simply is the system by which Angular determines whether something changed on the template of a component or inside of a component I should say, so whether it needs to change something in the template.. So whether some property value changed from 1 to 2 let's say and that property is output in the template, well of course Angular needs to re-render that part of the template and ngDoCheck is a hook executed on every check Angular makes. Now important, on every check, so not just if something changed, a lot of times ngDoCheck will run because you clicked some button which doesn't change anything but still it's an event and on events, Angular has to check if something changed because how else would it know? You don't tell it, so it has to check on certain triggering events like you clicked somewhere or a timer fired or an observable was resolved and on these occasions, it will check your code and ngDoCheck will be executed.</li>
  <li>ngAfterContentInit -> this is called whenever the content which is projected via ng-content has been initialized. So not the view of the component itself but instead you could say the view of the parent component, especially the part which will get added to our component through ng-content.</li>
  <li>ngAfterContentCheck -> is executed whenever change detection checked this content we're projecting into our component.</li>
  <li>ngAfterViewInit -> is then reached once the view of our own component has been finished initializing, so once our view has been rendered you could say. </li>
  <li> ngAfterViewChecked -> is called whenever our view has been checked, so once we are sure that either all changes which had to be done were displayed in the view or no changes were detected by Angular.</li>
  <li>ngOnDestroy -> if you destroy a component, for example if you placed ngIf on it and this gets then set to false and therefore it removes it from the DOM, ngOnDestroy is called and here's a great place to do some clean up work because this is called right before the object itself will be destroyed by Angular.</li>
</ul>


<hr>
<h3>Lesson 77 -> Seeing Lifecycle Hooks in Action</h3>

<app-l77-lifecycle></app-l77-lifecycle>
